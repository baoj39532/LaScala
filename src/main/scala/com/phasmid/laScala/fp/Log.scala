package com.phasmid.laScala.fp

import org.slf4j.{Logger, LoggerFactory}

import scala.util._

/**
  * Case class to support functional logging.
  *
  * NOTE: currently functional logging via Log will always be at debug level.
  *
  * NOTE: the non-strict String parameter (x) is evaluated inside Try.
  *
  * NOTE: the empty parentheses are because a case class cannot have a non-strict (i.e. call-by-name) parameter in its first parameter set.
  *
  * @param x      the lazy value of X
  * @param logger (implicit) the logger to be used to do the logging.
  * @tparam X the type of x and the return type of method log
  */
case class Log[X]()(x: => X)(implicit logger: Logger) {

  /**
    * This method is invoked by the application code on the Log object which is generated by the implicit conversion method (see Log companion object).
    * See LogSpec.scala for how to invoke logging in an application.
    *
    * NOTE: the non-strict String parameter (w) is not evaluated if debug is not enabled for the logger.
    *
    * @param w the string that will form the log message
    * @return the value of x
    */
  def log(w: => String): X = {
    // First, evaluate x inside Try
    val xy = Try(x)

    // Next, use the result to generate an appropriate log message (or none, as appropriate)
    val so = xy match {
      case Success(z) => if (logger.isDebugEnabled()) {
        val v = if (w contains Log.brackets) w else w + ": " + Log.brackets
        Some(v.replace(Log.brackets, Log.formatMessage(z)))
      }
      else None
      case Failure(t) => Some(s"<<Log.log: exception thrown for $w: ${t.getLocalizedMessage}>>")
    }

    // Then, do the logging, if appropriate
    so foreach logger.debug

    // Finally, return the value of x, or throw an exception: which is what would have happened without the log call
    xy.get
  }
}

object Log {

  import scala.language.implicitConversions

  implicit val logger: Logger = LoggerFactory.getLogger(classOf[Log[_]])

  implicit def logInt(x: => Int): Log[Int] = Log()(x)

  implicit def logDouble(x: => Double): Log[Double] = Log()(x)

  implicit def logString(x: => String): Log[String] = Log()(x)

  implicit def logLong(x: => Long): Log[Long] = Log()(x)

  implicit def logBigInt(x: => BigInt): Log[BigInt] = Log()(x)

  implicit def logChar(x: => Char): Log[Char] = Log()(x)

  implicit def logTraversable(x: => Traversable[_]): Log[Traversable[_]] = Log()(x)

  /**
    * This is pattern which, if found in the message, will be substituted for
    */
  val brackets: String = "{}"

  private def formatMessage[X](x: X): String = x match {
    case () => "()"
    // NOTE: If the value to be spied on is a Stream, we arbitrarily show the first 5 items
    // (Be Careful: potential side-effect: if the actual invoker doesn't evaluate as many as 5 items, we will have evaluated more than are necessary)
    case s: Stream[_] => s"[Stream showing at most 5 items] ${s.take(5).toList}"
    // NOTE: If the value to be spied on is Success(_) then we invoke spy on the underlying value and capture the message generated
    //    case Success(z) =>
    //      val sb = new StringBuilder("")
    //
    //      implicit def spyFunc(s: String): Spy = Spy(sb.append(s))
    //
    //      // CONSIDER reworking this so that the result is "Success(...)" instead of "Success: ..."
    //      spy(s"Success", z, b)
    //      sb.toString
    // NOTE: If the value to be spied on is Failure(_) then we invoke get the localized message of the cause
    case Failure(t) => s"Failure($t)"
    // NOTE: If the value to be spied on is Future(_) then we invoke spy on the underlying value when it is completed
    //    case f: Future[_] =>
    //      import scala.concurrent.ExecutionContext.Implicits.global
    //      f.onComplete(spy("Future", _, b))
    //      "to be provided in the future"
    // NOTE: If the value to be spied on is a common-or-garden object, then we simply form the appropriate string using the toString method
    case _ => if (x != null) x.toString else "<<null>>"
  }

}

